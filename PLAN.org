* DONE [#B] Code quality: maintainability, clarity, and minimalism review
  Goal: Improve code maintainability, modularity, clarity, and minimize dependencies where practical.
  Notes:
  - Focus on making code easier to understand, modify, and extend without breaking things
  - Remove unnecessary complexity and improve separation of concerns
  - Better error handling and resource cleanup patterns
  - Evaluate if dependencies can be reduced (prefer stdlib when sufficient)
  - Document key architectural decisions inline
  - All changes must preserve existing functionality (zero regressions)
  Date: 2025-12-29

** [#C] Backend: improve error handling and resource cleanup
   Why: Several functions ignore errors; goroutine cleanup paths unclear; better patterns improve robustness
   Change:
   - session.Write currently drops errors silently; add error return or log
   - Review session close: ensure all 3 goroutines terminate cleanly on Close()
   - Add context-based cancellation for clean shutdown
   - Audit all defer statements for proper error handling
   - Add error wrapping with context where helpful
   Tests: go test ./...; verify no test regressions
   Done when: Error paths properly handled; goroutine lifecycle is clear and leak-free

** [#C] Backend: evaluate gorilla/websocket dependency
   Why: Minimalism goal; check if golang.org/x/net/websocket or stdlib alternatives sufficient
   Change:
   - Research: does gorilla provide critical features we need? (check origin, control frames, etc)
   - If x/net/websocket is sufficient, migrate to reduce dependencies
   - If gorilla is best choice, document why (e.g., better API, production-ready, control frame handling)
   - Decision: keep or replace, but document the reasoning
   Tests: go test ./...; manual WebSocket connection test if migrating
   Done when: Dependency decision documented; migration complete if chosen

** [#C] Backend: improve modularity in manager and session
   Why: Manager and Session mix multiple concerns; better separation aids testing and future changes
   Change:
   - Extract broadcast/subscriber logic into separate Broadcaster type
   - Consider separating Manager's ID generation, session registry, and lifecycle management
   - Make Session goroutine coordination more explicit (use explicit done channels, context)
   - Add state machine to Session (e.g., connecting → ready → closing → closed)
   - Reduce coupling: Session shouldn't need to know about subscribers; Broadcaster should
   Tests: go test ./...; maintain or improve test coverage
   Done when: Each type has single clear responsibility; easier to modify independently

** [#C] Backend: clarify Windows PTY support and build tags
   Why: Windows returns stub error; status unclear to users/contributors
   Change:
   - Add detailed doc comment in pty_windows.go explaining ConPTY implementation status
   - Document options: implement ConPTY, use github.com/UserExistsError/conpty, or stay stub
   - Add build tag documentation explaining Unix vs Windows behavior
   - If keeping stub, improve error message to guide Windows users
   Tests: Build on Windows; verify error message is helpful
   Done when: Windows support status is crystal clear; path forward documented

** [#C] Backend: refactor API handlers for clarity
   Why: REST handlers mix parsing, validation, auth, business logic; hard to test and modify
   Change:
   - Extract middleware: authMiddleware, loggingMiddleware, jsonErrorMiddleware
   - Create path parsing helpers with unit tests (parseTerminalPath is buried in handler)
   - Centralize validation (e.g., validateTerminalID, validateCreateRequest)
   - Standardize JSON error responses (consistent structure)
   - Consider thin handler layer that delegates to service methods
   Tests: Add unit tests for parsing and validation; go test ./...
   Done when: Handlers are <20 lines; logic is tested; auth/validation centralized

** [#C] Frontend: fix terminal lifecycle to preserve state on tab switch
   Why: Terminal.svelte recreates xterm on every mount; destroys on unmount; loses state
   Change:
   - Move terminal instance ownership to parent or store (don't create in component)
   - Terminal.svelte becomes presentation-only: receives term instance, renders it
   - Preserve WebSocket connections across tab switches or implement reconnection
   - Use CSS display:none for hidden terminals instead of destroying components
   Tests: npm run build; manual tab switching; verify terminal state preserved
   Done when: Switching tabs keeps terminal scrollback and state intact

** [#C] Frontend: remove unused dependencies
   Why: Minimalism; addon-attach is installed but not imported anywhere
   Change:
   - Remove @xterm/addon-attach from package.json (unused)
   - Evaluate @xterm/addon-fit: it's ~10 lines of math; could inline if desired
   - If keeping addon-fit, document why (convenience, maintenance, tested)
   - Check for other unused dependencies
   Tests: npm run build; manual resize test
   Done when: Only necessary deps remain; decision documented if keeping addon-fit

** [#C] Frontend: improve WebSocket error handling
   Why: Connection failures show generic "disconnected"; no retry logic; poor UX
   Change:
   - Add exponential backoff reconnection for WebSocket failures
   - Show user-friendly messages: "Connecting...", "Connection lost, retrying...", "Connected"
   - Handle auth failures (401) differently from network errors
   - Add manual reconnect button after repeated failures
   - Log errors to console for debugging
   Tests: npm run build; manual test with network interruption
   Done when: Users get clear feedback; auto-reconnect works for transient failures

** [#C] Documentation: add architectural inline comments
   Why: Code lacks context on design decisions; onboarding is harder than needed
   Change:
   - Add package doc comments to internal/terminal, internal/api, internal/orchestrator
   - Document goroutine coordination pattern in session.go (who owns what, shutdown order)
   - Explain WebSocket control message protocol in terminal_handler.go
   - Document thread-safety guarantees in Manager (what locks protect what)
   - Add comment explaining why we use fan-out pattern for subscribers
   Tests: None (documentation only)
   Done when: Key patterns and decisions are documented; code is self-explanatory

** [#C] Testing: improve coverage and testability
   Why: Some code paths untested; mocking is hard; no integration tests
   Change:
   - Add tests for parseTerminalPath, validateToken, path parsing edge cases
   - Make Manager testable: inject clock interface for testing timeouts/timestamps
   - Add table-driven tests for shell selection logic
   - Create integration test: spawn terminal, connect WebSocket, send/receive data
   - Document testing approach in README or TESTING.md
   Tests: go test ./...; verify coverage increases
   Done when: Critical paths tested; testing strategy documented

* DONE [#A] Initial project structure with multi-terminal dashboard
  Goal: Set up Gestalt IDE foundation with Go backend, Svelte frontend, and WebSocket-based terminal management system that supports inter-terminal communication.

  Notes:
  - Terminals are not just user-interactive but can read/write to each other
  - AI agents (like Copilot) should be able to monitor and inject commands into terminals
  - Dashboard shows splash page with status + terminal tabs
  - Architecture must be modular from the start to support terminal orchestration
  - Use github.com/creack/pty for PTY management
  - Use gorilla/websocket for WebSocket handling
  - Keep dependencies minimal
  - Decisions confirmed: repo layout = cmd/gestalt + internal, terminal IDs = short incremental, auth = origin checks + token
  - Decisions confirmed: Windows PTY = ConPTY only (no fallback), auth token = Bearer header for REST and WS, Windows shell = system default unless overridden
  - Decisions pending/implicit: shell selection policy on Unix (use $SHELL vs fallback), WebSocket control framing (text JSON for control + binary for data), bell handling (client-side on xterm onBell)
  - Frontend choice: use Vite + Svelte (not SvelteKit) for a lighter integration with Go server

** Set up Go backend structure and dependencies
   Why: Need the server foundation before implementing terminal logic
   Change:
   - Initialize go.mod with module name
   - Decide repo layout (e.g., cmd/gestalt/main.go + internal/{api,terminal,orchestrator})
   - Create main.go with basic HTTP server and config (port, shell command, auth token)
   - Add OS-aware shell default (use $SHELL on Unix; configurable fallback on Windows)
   - Add gorilla/websocket and creack/pty dependencies
   - Create modular package structure:
     - terminal/ - PTY and terminal session management
     - api/ - HTTP/WebSocket handlers
     - orchestrator/ - Inter-terminal communication logic (stub for now)
   Tests: Server starts and responds on port 8080
   Done when: Go project compiles, dependencies resolved, basic server runs

** Implement terminal session manager with inter-terminal awareness
   Why: Core abstraction for managing multiple terminal instances and their communication
   Change:
   - Create terminal/session.go with Terminal session struct
   - Each terminal has: ID, PTY, input/output channels, metadata (including role/purpose)
   - Create terminal/manager.go to track all active sessions
   - Manager provides: Create, Get, List, Delete operations
   - Add hooks for inter-terminal communication (Reader/Writer interfaces or fan-out)
   - Support terminal output broadcast to multiple listeners
   - Define lifecycle rules (close cleanup, optional idle timeout)
   - Decide output buffer size/format for later API (lines vs bytes)
   - Implement incremental ID generator (atomic counter) with string rendering
   Tests: Can create multiple terminal sessions, list them, retrieve by ID
   Done when: Manager can spawn/track terminals with communication hooks

** Implement WebSocket terminal bridge
   Why: Connect browser frontend to backend PTY sessions
   Change:
   - Create api/terminal_handler.go for WebSocket upgrade
   - Implement bidirectional bridge: WebSocket ↔ PTY (binary data frames)
   - Define control message framing for resize (text JSON messages, e.g. {"type":"resize","cols":...,"rows":...})
   - Handle terminal resize events (apply to PTY; SIGWINCH optional)
   - Support multiplexing: one WebSocket can subscribe to terminal output (fan-out)
   - Add basic origin checks (and optional token auth if required)
   - Add endpoints: /ws/terminal/:id for connecting to specific terminal
   Tests: Can connect via WebSocket, send input, receive output
   Done when: WebSocket bidirectionally bridges to PTY with resize support

** Create REST API for terminal management
   Why: Dashboard needs to query status and create/delete terminals
   Change:
   - Create api/routes.go with REST endpoints
   - GET /api/terminals - list all terminals with metadata
   - POST /api/terminals - create new terminal session
   - DELETE /api/terminals/:id - terminate terminal
   - GET /api/status - system status (terminal count, etc)
   - Define response schema (id, title, role, created_at, status)
   - Require token for REST endpoints (Authorization header or query param)
   Tests: Can create/list/delete terminals via REST API
   Done when: All CRUD operations work via HTTP

** Initialize Svelte frontend structure
   Why: Need frontend framework before building UI components
   Change:
   - Use Vite + Svelte (not SvelteKit) for minimal integration with Go server
   - Run `npm create vite@latest frontend -- --template svelte`
   - Install xterm.js and addons: xterm, xterm-addon-fit, xterm-addon-attach
   - Configure Vite to proxy API calls to Go backend (port 8080)
   - Create basic app structure with routing (splash, terminal views)
   Tests: Frontend dev server runs, builds successfully
   Done when: Svelte app runs with xterm.js dependencies installed

** Build splash page dashboard component
   Why: Entry point showing system status and terminal management
   Change:
   - Create Dashboard.svelte component
   - Fetch /api/status and /api/terminals on mount
   - Display: terminal count, system info, list of active terminals
   - Add "New Terminal" button (calls POST /api/terminals)
   - Style with minimal CSS (clean, functional)
   Tests: Dashboard loads, shows correct terminal count, button creates terminal
   Done when: Splash page displays status and can create terminals

** Build terminal tab component with xterm.js
   Why: Display interactive terminals in browser
   Change:
   - Create Terminal.svelte component
   - Initialize xterm.js instance with fit addon
   - Connect to WebSocket /ws/terminal/:id (send resize control JSON on fit)
   - Handle terminal resize on window resize
   - Hook xterm onBell for bell interception/notifications
   - Implement terminal cleanup on component destroy
   Tests: Terminal renders, accepts input, displays output correctly
   Done when: Fully interactive terminal works in browser

** Implement tab switching UI
   Why: Users need to switch between multiple terminals
   Change:
   - Create TabBar.svelte component
   - Maintain array of open terminal tabs (IDs + labels)
   - Switch active terminal on tab click
   - Add close button per tab (calls DELETE /api/terminals/:id)
   - Keep splash page as special "tab 0"
   Tests: Can switch between splash and terminal tabs, close tabs
   Done when: Tab navigation works smoothly

** Wire up complete application flow
   Why: Connect all pieces into working application
   Change:
   - Create App.svelte as main component orchestrator
   - Manage global state: active terminals, current tab
   - Route between splash and terminal views
   - Handle terminal creation → open new tab → connect WebSocket
   - Serve frontend build from Go backend in production
   Tests: Full flow works: splash → create terminal → interact → switch tabs → close
   Done when: Complete application runs end-to-end

** Add basic inter-terminal read capability (foundation)

** Preserve terminal screen buffer across tab switches
   Why: Switching away and back currently wipes the terminal display while the session is still running.
   Change: Rework terminal view lifecycle so xterm DOM/state is preserved or restored on tab reselect (avoid dispose on hide or buffer snapshot/restore).
   Tests: Manual verify tab switching retains visible terminal content; existing go tests still pass.
   Done when: Returning to a terminal shows the same screen contents without requiring a reflow or replay.
   Why: Lay groundwork for terminal orchestration features
   Change:
   - Add GET /api/terminals/:id/output endpoint (recent output buffer)
   - Each terminal maintains circular buffer of recent output (~1000 lines)
   - Document API for reading terminal state (for future AI agent integration)
   - Add metadata field for terminal "role" or "purpose" (future use)
   Tests: Can retrieve recent output from terminal via API
   Done when: API endpoint returns buffered terminal output
