* WIP [#B] Fix agent shell args + toast-to-log parity
  Goal: Allow agent shell strings to include arguments, and ensure every toast is also logged.
  Notes:
  - Current agent shell field appears to be a single string passed to exec without args.
  - Desired: support space-separated args (and optionally quoted args) in the shell string.
  - Ensure frontend toasts also emit structured log entries so they appear in Logs view and /api/logs.
  - Keep behavior minimal and explicit; avoid new dependencies unless required.
** DONE [#B] Support shell string arguments in agent config
   Why: Agents like copilot require a shell/command plus flags in config.
   Change:
   - Parse agent.Shell into command + args (define parsing rules, e.g., shlex-like or simple split)
   - Update session/terminal spawn to accept argv rather than only a single path
   - Update validation and tests for parsing edge cases
   Tests: Unit tests for parsing; go test ./...
   Done when: Agent shell config accepts args and agent launches correctly
** DONE [#B] Log all toast notifications to backend logs
   Why: User-facing toasts must be discoverable in the Logs tab and /api/logs.
   Change:
   - Identify toast creation flow in frontend
   - Ensure each toast emission also creates a log entry (client-side via /api/logs or server-side via logger hooks)
   - Keep log level aligned with toast level
   Tests: Frontend behavior + backend log visibility; go test ./...
   Done when: Every toast is mirrored in backend logs

* DONE [#B] Multi-prompt injection on agent startup
  Goal: Extend agent configuration to support multiple prompts injected sequentially on terminal start.
  Notes:
  - Current: agent has "prompt_file" (string) that references a single file
  - Desired: agent has "prompt" field that can be string OR array of strings
  - Each string is a prompt name (not full path); resolve to config/prompts/{name}.txt
  - Example: "prompt": ["coder", "architect"] → inject coder.txt then architect.txt
  - Backward compatibility for "prompt_file" requires explicit decision
  - Prompts injected sequentially with small delay between each (e.g., 100ms)
  - Empty/missing prompt field means no injection (current default behavior)
  Date: 2025-12-29

** [#B] Confirm prompt_file compatibility decision
   Why: Avoid breaking existing configs without explicit approval
   Change: Decide whether to keep supporting "prompt_file" or remove it
   Tests: None (decision only)
   Done when: Compatibility approach is confirmed

** [#B] Update Agent struct to support prompt array
   Why: Need to accept both single string and array of strings for prompts
   Change:
   - Add new field: Prompts []string `json:"prompt"` to Agent struct
   - Remove PromptFile string `json:"prompt_file"` field entirely
   - Update Validate() to handle new format
   - Update JSON unmarshaling to accept both "prompt": "single" and "prompt": ["multi"]
   - Implement custom UnmarshalJSON if needed for flexible string/array parsing
   Tests: Unit tests for JSON parsing with string, array, empty, nil; validation logic
   Done when: Agent struct accepts prompt field as string or string array

** [#B] Update agent loader to resolve prompt names to paths
   Why: Prompts are stored as names but need to be validated/resolved to file paths
   Change:
   - Add PromptsDir parameter to Loader.Load() (default: "config/prompts")
   - After loading each agent JSON, validate that all prompt names exist as .txt files
   - Keep names in Agent struct; resolve paths during injection (more flexible)
   - Use structured logger to log warning if prompt file doesn't exist
   - Don't fail agent load on missing prompt (graceful degradation)
   - Update loader tests to check prompt file existence validation
   Tests: Unit tests with missing prompt files; verify warnings logged
   Done when: Loader validates prompt names against config/prompts/*.txt

** [#B] Implement sequential prompt injection in session startup
   Why: Multiple prompts need to be injected in order with proper timing
   Change:
   - Locate current prompt injection code (likely in terminal/session.go or manager.go)
   - Replace single prompt file read with loop over agent.Prompts
   - For each prompt name: resolve to config/prompts/{name}.txt, read contents, inject
   - Add configurable delay between prompts (default 100ms) to allow shell processing
   - Use structured logger for warnings if file missing/unreadable, continue with next prompt
   - Consider: inject after shell is ready (existing delay before first prompt)
   - Ensure newlines are properly handled (add \n at end if missing)
   Tests: Manual test with agent using multiple prompts; verify execution order
   Done when: Agent terminals execute all prompts in sequence on startup

** [#C] Update example agent configs to use new format
   Why: Demonstrate new prompt field format and provide working examples
   Change:
   - Update config/agents/*.json to use "prompt" field instead of "prompt_file"
   - Create example with single prompt: "prompt": "coder"
   - Create example with multiple prompts: "prompt": ["coder", "architect"]
   - Keep one example without prompts to show optional nature
   Tests: Load examples; verify they parse and execute correctly
   Done when: Example configs demonstrate new prompt field usage

** [#C] Update documentation for prompt configuration
   Why: Users need to understand new prompt field format and behavior
   Change:
   - Update README.md Agent Profiles section with prompt field documentation
   - Document both formats: "prompt": "single" and "prompt": ["multi"]
   - Document prompt resolution: names → config/prompts/{name}.txt
   - Document injection timing and sequential behavior
   Tests: None (documentation only)
   Done when: README clearly explains prompt field usage

** [#C] Delay initial prompt injection by 1s
   Why: Give shells time to initialize before prompt injection
   Change: Increase the initial prompt delay to 1s before the first prompt
   Tests: Go tests covering prompt injection timing
   Done when: First prompt waits ~1s before injection

** [#C] Inject trailing enter after prompts
   Why: Ensure shell executes prompts cleanly after all injections
   Change: Write a final newline after all prompts are injected
   Tests: Go tests for prompt injection order with trailing enter
   Done when: Prompt injection sends a trailing enter after the last prompt

** [#C] Ensure prompt injection sends terminal enter key
   Why: Some shells/CLI tools may require carriage return to submit input
   Change: Normalize prompt line endings and final enter to use terminal enter semantics
   Tests: Go tests verifying injected input uses the correct enter sequence
   Done when: Injected prompts are accepted by the LLM CLI

** [#C] Increase initial prompt delay to 3s
   Why: Some agents need more startup time before accepting prompt injection
   Change: Increase initial prompt delay from 1s to 3s
   Tests: Go tests covering prompt injection timing
   Done when: First prompt waits ~3s before injection

** [#B] Align injected enter with actual terminal input
   Why: Prompt text appears but is not submitted without manual Enter
   Change: Match injected enter sequence to what the web terminal sends (CR vs CRLF) and adjust prompt normalization
   Tests: Go tests to verify injected bytes match expected enter sequence
   Done when: Prompts submit without manual Enter across agents

** [#C] Delay final enter after prompt injection
   Why: Prompt text appears but enter may be arriving before the CLI is ready
   Change: Add a ~500ms delay before sending the final enter after all prompts
   Tests: Go tests covering prompt injection timing
   Done when: Prompts submit without manual Enter

** [#B] Pace prompt injection to mimic keystrokes
   Why: Prompt text appears but is not submitted; fast bulk writes may be treated differently
   Change: Write prompt content in small chunks with brief delays, then send a delayed enter
   Tests: Go tests for prompt injection ordering and final enter timing
   Done when: Prompts submit without manual Enter across agents

** [#B] Use raw prompt content with typed enter sequence
   Why: Copilot CLI may not accept normalized line endings
   Change: Stop normalizing prompt content; send raw bytes then a simulated enter sequence
   Tests: Go tests verifying raw prompt payload and enter write
   Done when: Copilot accepts injected prompts without manual Enter

** [#A] Gate prompt injection on onair_string output
   Why: Ensure prompts are only injected after the CLI is ready
   Change: Add per-agent onair_string configuration; wait for terminal output to contain it before injecting
   Tests: Go tests simulating output detection and deferred injection
   Done when: Prompt injection waits for onair_string before sending prompts

* DONE [#A] System logging and notification infrastructure
  Goal: Add comprehensive logging system with UI visibility through both toast notifications and dedicated logs tab.
  Notes:
  - Backend warnings (missing prompt files, agent load errors, etc.) must be visible in UI
  - Two-layer approach: ephemeral toasts for immediate feedback + persistent logs tab
  - Backend maintains circular log buffer accessible via REST API
  - Frontend uses Svelte store for notifications with auto-dismiss
  - Toast notifications: auto-dismiss after 3-5s (configurable), support info/warning/error levels
  - Logs tab: persistent view showing all system logs with filtering by level/time
  - WebSocket optional for real-time log streaming (can start with polling)
  - Log levels: DEBUG, INFO, WARNING, ERROR (standard severity)
  Date: 2025-12-29

** [#B] Create backend log buffer and structured logging
   Why: Need centralized log collection that both stdout and API can access
   Change:
   - Create internal/logging package with LogBuffer (circular buffer, thread-safe)
   - LogEntry struct: Timestamp, Level (debug/info/warning/error), Message, Context (map)
   - Default buffer size: 1000 entries (configurable)
   - Create Logger wrapper that writes to both stdout and LogBuffer
   - Replace log.Printf calls with structured logger throughout codebase
   - Logger methods: Debug(), Info(), Warn(), Error()
   - Include contextual fields (e.g., agent_id, terminal_id where relevant)
   Tests: Unit tests for LogBuffer thread-safety, circular behavior, entry limits
   Done when: All backend logging goes through structured logger with buffer

** [#B] Add REST endpoint for log retrieval
   Why: Frontend needs to fetch logs for display in logs tab
   Change:
   - Add GET /api/logs endpoint with query parameters: since (timestamp), level (filter), limit
   - Return JSON array of log entries with timestamp, level, message, context
   - Support pagination: last N entries or entries since timestamp
   - Default: return last 100 entries
   - Add filtering by log level (e.g., ?level=warning returns warning+error only)
   - Consider: HEAD request for log count or latest timestamp (polling optimization)
   Tests: REST endpoint tests with various query parameters
   Done when: Frontend can fetch filtered log history via REST

** [#C] Add WebSocket endpoint for real-time log streaming (optional)
   Why: Real-time log updates provide better UX than polling
   Change:
   - Add GET /ws/logs WebSocket endpoint for log streaming
   - Send log entries as JSON messages when they occur
   - Support client-side level filtering (client sends filter on connect)
   - Reuse existing WebSocket auth pattern (token in query param)
   - Handle subscriber cleanup on disconnect
   - Optional: implement later if REST polling is sufficient initially
   Tests: WebSocket connection test, message delivery test
   Done when: Logs stream to connected WebSocket clients in real-time

** [#B] Create frontend notification store
   Why: Centralized notification state management for toast display
   Change:
   - Create src/lib/notificationStore.js with Svelte writable store
   - Notification object: id, level, message, timestamp, autoClose, duration
   - Methods: addNotification(level, message, opts), dismiss(id), clear()
   - Auto-dismiss logic: setTimeout for toasts, optional permanent notifications
   - Default duration: 5000ms for info, 7000ms for warning, manual for error
   - Unique ID generation (timestamp + counter)
   - Export subscribe() for reactive updates
   Tests: Store tests for add/dismiss/auto-dismiss behavior
   Done when: Notification store manages toast lifecycle

** [#B] Create toast notification component
   Why: Visual display of ephemeral notifications
   Change:
   - Create src/components/Toast.svelte for individual toast
   - Create src/components/ToastContainer.svelte for positioning/stacking
   - Position: top-right or bottom-right corner (configurable)
   - Stack vertically with smooth enter/exit animations (slide + fade)
   - Visual styling: color-coded by level (info=blue, warning=yellow, error=red)
   - Include dismiss button (X) and auto-close progress indicator
   - Support click-to-dismiss
   - Accessibility: ARIA live region for screen readers
   Tests: Manual visual testing; verify animations and auto-dismiss
   Done when: Toasts display and auto-dismiss correctly

** [#B] Create logs tab view
   Why: Persistent access to system logs with filtering and search
   Change:
   - Create src/views/LogsView.svelte as dedicated tab
   - Add "Logs" tab to TabBar (between Dashboard and terminal tabs)
   - Display log entries in scrollable list/table: timestamp, level badge, message
   - Add level filter dropdown (All, Info, Warning, Error)
   - Add auto-refresh toggle (poll every 5s) and manual refresh button
   - Show entry count and latest update time
   - Expand log entry on click to show full context/details
   - Reverse chronological order (newest first)
   - Consider: virtualized scrolling for large log lists
   Tests: Manual testing with various log volumes and filters
   Done when: Logs tab displays backend logs with filtering

** [#B] Wire notifications into existing code paths
   Why: Emit notifications for key user-facing events
   Change:
   - Backend: emit warning logs for missing prompt files, agent load failures
   - Backend: emit info logs for terminal create/destroy, agent startup
   - Frontend: subscribe to notifications in App.svelte
   - Frontend: show toast on terminal connection errors, auth failures
   - Frontend: show toast on API errors (replace inline error text where appropriate)
   - Frontend: poll /api/logs on logs tab mount, display in LogsView
   - Optional: WebSocket log streaming if implemented
   Tests: Trigger various scenarios; verify toasts and logs appear
   Done when: Users see notifications for all important system events

** [#C] Add notification preferences (optional enhancement)
   Why: Users may want to customize notification behavior
   Change:
   - Add settings panel (modal or dedicated view) for notification prefs
   - Toggles: enable/disable toasts, auto-dismiss duration, log level filter
   - Store preferences in localStorage
   - Apply prefs to notification store configuration
   - Default: all notifications enabled
   Tests: Manual testing of preference persistence and application
   Done when: Users can customize notification behavior (optional)

** [#C] Update documentation for logging system
   Why: Developers and users need to understand logging capabilities
   Change:
   - Add "Logging and Notifications" section to README.md
   - Document log levels and when each is used
   - Document /api/logs endpoint and query parameters
   - Document toast notification behavior and auto-dismiss
   - Add screenshot or description of logs tab
   - Document how to add logs in backend code (logger usage)
   Tests: None (documentation only)
   Done when: Logging system is documented in README

* DONE [#B] Agent profiles system
  Goal: Allow customizable terminal configurations for AI agents stored as JSON files in config/agents/.
  Notes:
  - Each agent profile defines: shell/program, initial prompt file, terminal name, LLM type, LLM model
  - Agent profiles live in config/agents/ as JSON files (one per agent)
  - LLM types: copilot, codex, promptline (hardcoded for now)
  - LLM model: "default" for now (future: configurable)
  - Agent selection: via REST API (POST /api/terminals with "agent" parameter)
  - Default behavior: if no agent specified, use current shell-based creation
  - Initial prompt: if specified, write to terminal stdin after spawn
  - UI: one button per agent file, labeled with agent's name attribute
  Date: 2025-12-29

** [#B] Create agent data structure and JSON schema
   Why: Define the agent profile format before loading/using agents
   Change:
   - Create internal/agent/ package with Agent struct
   - Fields: Name (string), Shell (string), PromptFile (string), LLMType (string), LLMModel (string)
   - Add JSON tags for serialization: name, shell, prompt_file, llm_type, llm_model
   - Document schema with example JSON in agent/doc.go
   - Add validation: LLMType must be one of [copilot, codex, promptline]
   - Add validation: required fields (Name, Shell), optional (PromptFile)
   Tests: Unit test JSON marshaling/unmarshaling; validate edge cases
   Done when: Agent struct exists with JSON support and validation

** [#B] Implement agent loader from config/agents/
   Why: Load agent profiles from filesystem at startup
   Change:
   - Create agent.Loader with Load(dir string) (map[string]Agent, error)
   - Scan config/agents/*.json files
   - Parse each JSON file into Agent struct
   - Use filename (without .json) as agent ID
   - Return map[agentID]Agent for easy lookup
   - Handle errors: invalid JSON, validation failures, missing directory
   - If directory doesn't exist, return empty map (not an error)
   Tests: Unit tests with temp directories; valid/invalid JSON files
   Done when: Loader successfully reads agent profiles from directory

** [#B] Wire agent loader into Manager initialization
   Why: Manager needs access to agent profiles for terminal creation
   Change:
   - Add Agents field to ManagerOptions: map[string]agent.Agent
   - Load agents in cmd/gestalt/main.go before creating Manager
   - Pass agents to Manager via ManagerOptions
   - Store agents in Manager struct for lookup during Create
   - Add method Manager.GetAgent(id string) (Agent, bool)
   Tests: Integration test verifying Manager has agents after init
   Done when: Manager has access to loaded agent profiles

** [#B] Extend terminal creation API to accept agent
   Why: Frontend needs to specify which agent to use
   Change:
   - Extend createTerminalRequest to include Agent (optional string)
   - Modify Manager.Create signature: Create(agentID, role, title string) (*Session, error)
   - If agentID empty: use default behavior (current shell, no prompt, title/role as-is)
   - If agentID specified: lookup agent, use agent.Shell, override title with agent.Name
   - Pass agent to Session creation (extend newSession parameters)
   - Store agent reference in Session struct for later use
   Tests: REST API test with/without agent; verify correct shell launched
   Done when: POST /api/terminals accepts "agent" field

** [#C] Implement initial prompt injection
   Why: Agent profiles can specify a prompt file to execute on terminal start
   Change:
   - If agent.PromptFile is not empty, read file contents
   - After PTY starts, write prompt contents to session.input channel
   - Add newline at end if not present
   - Handle errors: file not found, read errors (log warning, continue)
   - Consider delay (50-100ms) after shell spawn before writing prompt
   Tests: Manual test with agent containing prompt file; verify execution
   Done when: Terminal executes prompt commands on startup

** [#C] Store LLM metadata in Session
   Why: Future features (orchestration, AI coordination) need to know terminal's LLM type/model
   Change:
   - Add LLMType and LLMModel fields to Session struct
   - Populate from agent profile during creation
   - Expose in SessionInfo for API responses
   - Extend terminalSummary JSON response to include llm_type and llm_model
   Tests: GET /api/terminals includes LLM metadata
   Done when: Session stores and exposes LLM configuration

** [#C] Add example agent profiles to config/agents/
   Why: Provide working examples for users
   Change:
   - Create config/agents/ directory
   - Add example agent profiles: copilot.json, codex.json, promptline.json
   - Each example uses /bin/bash (or appropriate shell)
   - Document agent profile format in main README.md
   Tests: Load examples; verify they parse correctly
   Done when: Example agent profiles exist and are documented

** [#C] Add GET /api/agents endpoint
   Why: Frontend needs to fetch available agent profiles
   Change:
   - Add GET /api/agents REST endpoint
   - Return array of agent metadata: id, name, llm_type, llm_model
   - Use Manager.Agents map to build response
   - Add unit tests for endpoint
   Tests: GET /api/agents returns agent list
   Done when: API endpoint exposes available agents

** [#C] Update frontend with agent buttons
   Why: Users need UI to spawn terminals with specific agents
   Change:
   - Fetch agents via GET /api/agents in Dashboard.svelte on mount
   - Render one button per agent using agent.name as button label
   - On button click: POST /api/terminals with {"agent": agentID}
   - Open new terminal tab after creation
   - Update terminal tab label to show agent.Name if used
   Tests: Manual test agent buttons in UI; verify correct terminal created
   Done when: Dashboard shows agent buttons; clicking spawns agent terminal

** [#B] Fix terminal tab close freeze and ensure deletion
   Why: Closing a tab freezes the UI and leaves a disconnected session
   Change:
   - Reproduce the close flow in App.svelte/TabBar.svelte
   - Ensure tab close triggers DELETE and removes the tab from UI
   - Fix any stale TerminalView/terminalStore references on close
   - Validate WebSocket shutdown cleanup on close
   Tests: npm run build; go test ./...
   Done when: Closing a tab removes it and the server session cleanly

* DONE [#B] Code quality: maintainability, clarity, and minimalism review
  Goal: Improve code maintainability, modularity, clarity, and minimize dependencies where practical.
  Notes:
  - Focus on making code easier to understand, modify, and extend without breaking things
  - Remove unnecessary complexity and improve separation of concerns
  - Better error handling and resource cleanup patterns
  - Evaluate if dependencies can be reduced (prefer stdlib when sufficient)
  - Document key architectural decisions inline
  - All changes must preserve existing functionality (zero regressions)
  Date: 2025-12-29

** [#C] Backend: improve error handling and resource cleanup
   Why: Several functions ignore errors; goroutine cleanup paths unclear; better patterns improve robustness
   Change:
   - session.Write currently drops errors silently; add error return or log
   - Review session close: ensure all 3 goroutines terminate cleanly on Close()
   - Add context-based cancellation for clean shutdown
   - Audit all defer statements for proper error handling
   - Add error wrapping with context where helpful
   Tests: go test ./...; verify no test regressions
   Done when: Error paths properly handled; goroutine lifecycle is clear and leak-free

** [#C] Backend: evaluate gorilla/websocket dependency
   Why: Minimalism goal; check if golang.org/x/net/websocket or stdlib alternatives sufficient
   Change:
   - Research: does gorilla provide critical features we need? (check origin, control frames, etc)
   - If x/net/websocket is sufficient, migrate to reduce dependencies
   - If gorilla is best choice, document why (e.g., better API, production-ready, control frame handling)
   - Decision: keep or replace, but document the reasoning
   Tests: go test ./...; manual WebSocket connection test if migrating
   Done when: Dependency decision documented; migration complete if chosen

** [#C] Backend: improve modularity in manager and session
   Why: Manager and Session mix multiple concerns; better separation aids testing and future changes
   Change:
   - Extract broadcast/subscriber logic into separate Broadcaster type
   - Consider separating Manager's ID generation, session registry, and lifecycle management
   - Make Session goroutine coordination more explicit (use explicit done channels, context)
   - Add state machine to Session (e.g., connecting → ready → closing → closed)
   - Reduce coupling: Session shouldn't need to know about subscribers; Broadcaster should
   Tests: go test ./...; maintain or improve test coverage
   Done when: Each type has single clear responsibility; easier to modify independently

** [#C] Backend: clarify Windows PTY support and build tags
   Why: Windows returns stub error; status unclear to users/contributors
   Change:
   - Add detailed doc comment in pty_windows.go explaining ConPTY implementation status
   - Document options: implement ConPTY, use github.com/UserExistsError/conpty, or stay stub
   - Add build tag documentation explaining Unix vs Windows behavior
   - If keeping stub, improve error message to guide Windows users
   Tests: Build on Windows; verify error message is helpful
   Done when: Windows support status is crystal clear; path forward documented

** [#C] Backend: refactor API handlers for clarity
   Why: REST handlers mix parsing, validation, auth, business logic; hard to test and modify
   Change:
   - Extract middleware: authMiddleware, loggingMiddleware, jsonErrorMiddleware
   - Create path parsing helpers with unit tests (parseTerminalPath is buried in handler)
   - Centralize validation (e.g., validateTerminalID, validateCreateRequest)
   - Standardize JSON error responses (consistent structure)
   - Consider thin handler layer that delegates to service methods
   Tests: Add unit tests for parsing and validation; go test ./...
   Done when: Handlers are <20 lines; logic is tested; auth/validation centralized

** [#C] Frontend: fix terminal lifecycle to preserve state on tab switch
   Why: Terminal.svelte recreates xterm on every mount; destroys on unmount; loses state
   Change:
   - Move terminal instance ownership to parent or store (don't create in component)
   - Terminal.svelte becomes presentation-only: receives term instance, renders it
   - Preserve WebSocket connections across tab switches or implement reconnection
   - Use CSS display:none for hidden terminals instead of destroying components
   Tests: npm run build; manual tab switching; verify terminal state preserved
   Done when: Switching tabs keeps terminal scrollback and state intact

** [#C] Frontend: remove unused dependencies
   Why: Minimalism; addon-attach is installed but not imported anywhere
   Change:
   - Remove @xterm/addon-attach from package.json (unused)
   - Evaluate @xterm/addon-fit: it's ~10 lines of math; could inline if desired
   - If keeping addon-fit, document why (convenience, maintenance, tested)
   - Check for other unused dependencies
   Tests: npm run build; manual resize test
   Done when: Only necessary deps remain; decision documented if keeping addon-fit

** [#C] Frontend: improve WebSocket error handling
   Why: Connection failures show generic "disconnected"; no retry logic; poor UX
   Change:
   - Add exponential backoff reconnection for WebSocket failures
   - Show user-friendly messages: "Connecting...", "Connection lost, retrying...", "Connected"
   - Handle auth failures (401) differently from network errors
   - Add manual reconnect button after repeated failures
   - Log errors to console for debugging
   Tests: npm run build; manual test with network interruption
   Done when: Users get clear feedback; auto-reconnect works for transient failures

** [#C] Documentation: add architectural inline comments
   Why: Code lacks context on design decisions; onboarding is harder than needed
   Change:
   - Add package doc comments to internal/terminal, internal/api, internal/orchestrator
   - Document goroutine coordination pattern in session.go (who owns what, shutdown order)
   - Explain WebSocket control message protocol in terminal_handler.go
   - Document thread-safety guarantees in Manager (what locks protect what)
   - Add comment explaining why we use fan-out pattern for subscribers
   Tests: None (documentation only)
   Done when: Key patterns and decisions are documented; code is self-explanatory

** [#C] Testing: improve coverage and testability
   Why: Some code paths untested; mocking is hard; no integration tests
   Change:
   - Add tests for parseTerminalPath, validateToken, path parsing edge cases
   - Make Manager testable: inject clock interface for testing timeouts/timestamps
   - Add table-driven tests for shell selection logic
   - Create integration test: spawn terminal, connect WebSocket, send/receive data
   - Document testing approach in README or TESTING.md
   Tests: go test ./...; verify coverage increases
   Done when: Critical paths tested; testing strategy documented

* DONE [#A] Initial project structure with multi-terminal dashboard
  Goal: Set up Gestalt IDE foundation with Go backend, Svelte frontend, and WebSocket-based terminal management system that supports inter-terminal communication.

  Notes:
  - Terminals are not just user-interactive but can read/write to each other
  - AI agents (like Copilot) should be able to monitor and inject commands into terminals
  - Dashboard shows splash page with status + terminal tabs
  - Architecture must be modular from the start to support terminal orchestration
  - Use github.com/creack/pty for PTY management
  - Use gorilla/websocket for WebSocket handling
  - Keep dependencies minimal
  - Decisions confirmed: repo layout = cmd/gestalt + internal, terminal IDs = short incremental, auth = origin checks + token
  - Decisions confirmed: Windows PTY = ConPTY only (no fallback), auth token = Bearer header for REST and WS, Windows shell = system default unless overridden
  - Decisions pending/implicit: shell selection policy on Unix (use $SHELL vs fallback), WebSocket control framing (text JSON for control + binary for data), bell handling (client-side on xterm onBell)
  - Frontend choice: use Vite + Svelte (not SvelteKit) for a lighter integration with Go server

** Set up Go backend structure and dependencies
   Why: Need the server foundation before implementing terminal logic
   Change:
   - Initialize go.mod with module name
   - Decide repo layout (e.g., cmd/gestalt/main.go + internal/{api,terminal,orchestrator})
   - Create main.go with basic HTTP server and config (port, shell command, auth token)
   - Add OS-aware shell default (use $SHELL on Unix; configurable fallback on Windows)
   - Add gorilla/websocket and creack/pty dependencies
   - Create modular package structure:
     - terminal/ - PTY and terminal session management
     - api/ - HTTP/WebSocket handlers
     - orchestrator/ - Inter-terminal communication logic (stub for now)
   Tests: Server starts and responds on port 8080
   Done when: Go project compiles, dependencies resolved, basic server runs

** Implement terminal session manager with inter-terminal awareness
   Why: Core abstraction for managing multiple terminal instances and their communication
   Change:
   - Create terminal/session.go with Terminal session struct
   - Each terminal has: ID, PTY, input/output channels, metadata (including role/purpose)
   - Create terminal/manager.go to track all active sessions
   - Manager provides: Create, Get, List, Delete operations
   - Add hooks for inter-terminal communication (Reader/Writer interfaces or fan-out)
   - Support terminal output broadcast to multiple listeners
   - Define lifecycle rules (close cleanup, optional idle timeout)
   - Decide output buffer size/format for later API (lines vs bytes)
   - Implement incremental ID generator (atomic counter) with string rendering
   Tests: Can create multiple terminal sessions, list them, retrieve by ID
   Done when: Manager can spawn/track terminals with communication hooks

** Implement WebSocket terminal bridge
   Why: Connect browser frontend to backend PTY sessions
   Change:
   - Create api/terminal_handler.go for WebSocket upgrade
   - Implement bidirectional bridge: WebSocket ↔ PTY (binary data frames)
   - Define control message framing for resize (text JSON messages, e.g. {"type":"resize","cols":...,"rows":...})
   - Handle terminal resize events (apply to PTY; SIGWINCH optional)
   - Support multiplexing: one WebSocket can subscribe to terminal output (fan-out)
   - Add basic origin checks (and optional token auth if required)
   - Add endpoints: /ws/terminal/:id for connecting to specific terminal
   Tests: Can connect via WebSocket, send input, receive output
   Done when: WebSocket bidirectionally bridges to PTY with resize support

** Create REST API for terminal management
   Why: Dashboard needs to query status and create/delete terminals
   Change:
   - Create api/routes.go with REST endpoints
   - GET /api/terminals - list all terminals with metadata
   - POST /api/terminals - create new terminal session
   - DELETE /api/terminals/:id - terminate terminal
   - GET /api/status - system status (terminal count, etc)
   - Define response schema (id, title, role, created_at, status)
   - Require token for REST endpoints (Authorization header or query param)
   Tests: Can create/list/delete terminals via REST API
   Done when: All CRUD operations work via HTTP

** Initialize Svelte frontend structure
   Why: Need frontend framework before building UI components
   Change:
   - Use Vite + Svelte (not SvelteKit) for minimal integration with Go server
   - Run `npm create vite@latest frontend -- --template svelte`
   - Install xterm.js and addons: xterm, xterm-addon-fit, xterm-addon-attach
   - Configure Vite to proxy API calls to Go backend (port 8080)
   - Create basic app structure with routing (splash, terminal views)
   Tests: Frontend dev server runs, builds successfully
   Done when: Svelte app runs with xterm.js dependencies installed

** Build splash page dashboard component
   Why: Entry point showing system status and terminal management
   Change:
   - Create Dashboard.svelte component
   - Fetch /api/status and /api/terminals on mount
   - Display: terminal count, system info, list of active terminals
   - Add "New Terminal" button (calls POST /api/terminals)
   - Style with minimal CSS (clean, functional)
   Tests: Dashboard loads, shows correct terminal count, button creates terminal
   Done when: Splash page displays status and can create terminals

** Build terminal tab component with xterm.js
   Why: Display interactive terminals in browser
   Change:
   - Create Terminal.svelte component
   - Initialize xterm.js instance with fit addon
   - Connect to WebSocket /ws/terminal/:id (send resize control JSON on fit)
   - Handle terminal resize on window resize
   - Hook xterm onBell for bell interception/notifications
   - Implement terminal cleanup on component destroy
   Tests: Terminal renders, accepts input, displays output correctly
   Done when: Fully interactive terminal works in browser

** Implement tab switching UI
   Why: Users need to switch between multiple terminals
   Change:
   - Create TabBar.svelte component
   - Maintain array of open terminal tabs (IDs + labels)
   - Switch active terminal on tab click
   - Add close button per tab (calls DELETE /api/terminals/:id)
   - Keep splash page as special "tab 0"
   Tests: Can switch between splash and terminal tabs, close tabs
   Done when: Tab navigation works smoothly

** Wire up complete application flow
   Why: Connect all pieces into working application
   Change:
   - Create App.svelte as main component orchestrator
   - Manage global state: active terminals, current tab
   - Route between splash and terminal views
   - Handle terminal creation → open new tab → connect WebSocket
   - Serve frontend build from Go backend in production
   Tests: Full flow works: splash → create terminal → interact → switch tabs → close
   Done when: Complete application runs end-to-end

** Add basic inter-terminal read capability (foundation)

** Preserve terminal screen buffer across tab switches
   Why: Switching away and back currently wipes the terminal display while the session is still running.
   Change: Rework terminal view lifecycle so xterm DOM/state is preserved or restored on tab reselect (avoid dispose on hide or buffer snapshot/restore).
   Tests: Manual verify tab switching retains visible terminal content; existing go tests still pass.
   Done when: Returning to a terminal shows the same screen contents without requiring a reflow or replay.
   Why: Lay groundwork for terminal orchestration features
   Change:
   - Add GET /api/terminals/:id/output endpoint (recent output buffer)
   - Each terminal maintains circular buffer of recent output (~1000 lines)
   - Document API for reading terminal state (for future AI agent integration)
   - Add metadata field for terminal "role" or "purpose" (future use)
   Tests: Can retrieve recent output from terminal via API
   Done when: API endpoint returns buffered terminal output
